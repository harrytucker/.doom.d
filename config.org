#+title: Harry's Doom Emacs Config
#+author: Harry Tucker

# HTML and LaTeX export --------------------------------------------------------
#+setupfile: org-themes/src/white_clean/white_clean.theme
#+options: toc:nil
#+latex_class: mimore
# ------------------------------------------------------------------------------

* About
Come one, come all and see the folly of a man trying to configure a perfect
Emacs setup. First, shut up the linter:
#+begin_src elisp
;;; -*- lexical-binding: t; -*-
#+end_src

Hopefully you find this useful in some manner if you want to configure Doom
Emacs in a similar way to mine.
** Build Information
#+begin_src elisp :tangle no
(emacs-version)
#+end_src

#+RESULTS:
: GNU Emacs 30.1 (build 2, aarch64-apple-darwin24.3.0, NS appkit-2575.40 Version 15.3.1 (Build 24D70))
:  of 2025-03-07

#+begin_src elisp :tangle no
system-configuration-options
#+end_src

#+RESULTS:
: --enable-locallisppath=/usr/local/share/emacs/site-lisp --infodir=/usr/local/Cellar/emacs-mac/emacs-28.2-mac-9.1/share/info --mandir=/usr/local/Cellar/emacs-mac/emacs-28.2-mac-9.1/share/man --prefix=/usr/local/Cellar/emacs-mac/emacs-28.2-mac-9.1 --with-mac --enable-mac-app=/usr/local/Cellar/emacs-mac/emacs-28.2-mac-9.1 --with-gnutls --with-modules --with-native-compilation 'CFLAGS=-I/usr/local/opt/gcc/include -I/usr/local/opt/libgccjit/include' 'LDFLAGS=-L/usr/local/lib/gcc/12 -I/usr/local/opt/gcc/include -I/usr/local/opt/libgccjit/include'

* Configuration
** User Identification
#+begin_src elisp
;; Emacs User Identification
(setq user-full-name "Harry Tucker"
      user-mail-address "tucker.harry@outlook.com")
#+END_SRC
** General
*** Visuals
**** Theme & Font
Dracula is my theme of choice, and JetBrains Mono my favourite font. By default,
Treemacs uses a colour scheme based on the Atom text editor, so I set this to
=doom-colors= match the rest of the editor.
#+begin_src elisp
;; Set themes for Doom and Treemacs, and select the JetBrains Mono font
(setq doom-theme 'doom-dracula
      doom-themes-treemacs-theme "doom-colors"
      doom-font (font-spec
                 :family "JetBrainsMono Nerd Font"
                 :size 14))
#+end_src
**** Splash Image
#+begin_src elisp
(defun random-element-of-list (items)
  "Return a random element from a given list."
  (let* ((size (length items))
         (index (random size)))
    (nth index items)))

(defun splash-images ()
  "Return a list of available splash images."
  (let*
      ((splash-directory (concat doom-user-dir "images/")))
    (directory-files splash-directory 'full (rx ".png" eos))))

;; Sets the splash image to a random PNG file from the splash image directory
(setq fancy-splash-image (random-element-of-list (splash-images)))
#+end_src
**** Modeline
This provides no functionality whatsoever, but I like having an icon that
displays the current major-mode in use.
#+begin_src elisp
;; Enables modeline icons with colour support
(setq doom-modeline-major-mode-icon t
      doom-modeline-major-mode-color-icon t)
#+end_src
**** Editor
Normally this is the first thing I set up for any given text editor. Pairing
delimiters by colour makes a lot of sense, and I find it makes code easier to
parse, so I've set this up globally across all programming modes.
#+begin_src elisp
;; Highlights scope with various colours, replaces rainbow-delimiters-mode
(add-hook! 'prog-mode-hook #'prism-mode)
(add-hook! 'python-mode-hook #'prism-whitespace-mode)
(add-hook! 'yaml-mode-hook #'prism-whitespace-mode)

;; Lower the delay for displaying potential key chords
(setq which-key-idle-delay 0.2)

;; Fancy, modern looking flycheck displays
;; (use-package! flyover
;;   :config
;;   (add-hook 'flycheck-mode-hook #'flyover-mode))

;; Enable precision scrolling globally
(pixel-scroll-precision-mode)

;; Automatically select help windows when they open
(setq help-window-select t)
#+end_src
**** Evil
I can use =undo-tree= as a linear system most of the time, which is what ends up
happening. In other cases, =undo-tree= basically provides a free stash of previous
code changes if I've been experimenting with some code, so is a nice escape
hatch to have, so I've enabled it as my undo system.
#+begin_src elisp
;; Allows undoing and redoing as a tree of changes, instead of being limited to
;; linear changes
(evil-set-undo-system 'undo-tree)
#+end_src
**** Eshell
Doom Emacs disables =eshell= from indicating colour support by default in order to
avoid running into issues with applications using it as an indicator of a fully
functional terminal emulator. I'm fine with working around that when it comes
up, since I can add to =eshell-visual-commands= when needed, so I've re-enabled
colour support.
#+begin_src elisp
;; Experimenting with Eshell's Plan 9 emulation, see here:
;; https://www.masteringemacs.org/article/complete-guide-mastering-eshell
(after! eshell
  (require 'em-smart)
  (eshell-smart-initialize)
  ;; Eshell's emulated echo doesn't seem to honour the -n flag.
  (setq eshell-plain-echo-behavior t
        eshell-visual-commands '()))

(use-package! eat
  :defer t
  :init
  ;; Use Emacs-eat. I've gotten rid of vterm as this works well enough for my purposes,
  ;; and I much prefer staying in Eshell.
  ;;
  ;; Using eat also requires unsetting eshell-visual-commands, done above here.
  (add-hook 'eshell-load-hook #'eat-eshell-mode))

;; Point bash-completion at the Homebrew installed Bash version as MacOS ships
;; an outdated Bash version.
(after! bash-completion
  (setq bash-completion-prog "/opt/homebrew/bin/bash"))
#+end_src
*** Projects
When using =projectile=, I don't want to search some directories that are just
noise, so I want to ignore them.
#+begin_src elisp
(use-package! projectile
  :defer
  :config
  ;; When looking for Go project files, I don't care about vendored dependencies
  (add-to-list 'projectile-globally-ignored-directories "*vendor"))
#+end_src
*** Completions
I'm trying out replacing =company-mode= with =corfu=. This is mainly because I've
read largely positive things about this new completion package and I'm hoping
it's a bit leaner and faster than =company-mode=.
#+begin_src elisp
(use-package! corfu
  :defer
  :config
  ;; Automatically select the first valid completion candidate
  (setq corfu-preselect 'prompt))
#+end_src
** Programming
*** Databases
I only really use PostgreSQL in my day-to-day, so I set it as my default SQL
product dialect. Auto formatting is configured with =apheleia-mode= to use
=pgformatter=, available on the Homebrew repository. Some configuration is
included for the PostgreSQL formatting to follow the style that I prefer.
#+begin_src elisp
;; Provides configuration for working with SQL within Emacs
(after! sql-mode
  ;; Use PostgreSQL
  (sql-set-product 'postgres)
  ;; Enable apheleia-mode in SQL buffers
  (add-hook 'sql-mode-hook #'apheleia-mode)
  ;; Use pg_format for formatting SQL files upon saving the buffer (set-formatter!
  (set-formatter!
    'pg_format '("pg_format"
                 "--comma-break"
                 "--keep-newline"
                 "-")
    :modes '(sql-mode)))

;; Doom disables SQL formatting by default, so you need to override this.
(delete 'sql-mode +format-on-save-disabled-modes)
#+end_src

Let's enable some Evil mode bindings for =pgmacs=:
#+begin_src elisp
;; PGmacs evil-mode integration
;; PGmacs is a PostgreSQL database browser that uses its own keymaps which don't
;; play nicely with evil-mode. This configuration sets up proper evil bindings.
;;
;; The key insight is that pgmacs uses `use-local-map' to set buffer-local keymaps,
;; which can conflict with evil's state-based keymaps. We need to:
;; 1. Suppress the conflicting keys in the original pgmacs keymaps
;; 2. Use evil-define-key* to properly bind keys in evil's normal state
(after! pgmacs
  ;; Set initial evil state to normal for PGmacs buffers
  (evil-set-initial-state 'pgmacs-mode 'normal)

  ;; Remove conflicting keybindings from pgmacs keymaps.
  ;; These keys (j, k, h, etc.) are used for navigation in evil-mode,
  ;; but pgmacs binds them to other functions.
  (dolist (key '("j" "k" "h" "d" "u" "i" "p" "g" "r" "v" "y"))
    (define-key pgmacs-table-list-map (kbd key) nil)
    (define-key pgmacs-table-list-map/table (kbd key) nil)
    (define-key pgmacs-row-list-map (kbd key) nil)
    (define-key pgmacs-row-list-map/table (kbd key) nil)
    (define-key pgmacs-proc-list-map (kbd key) nil))

  ;; Table list buffer bindings (main database view)
  (evil-define-key* 'normal pgmacs-table-list-map
    "j" #'evil-next-line
    "k" #'evil-previous-line
    "l" #'pgmacstbl-next-column
    "h" #'pgmacstbl-previous-column
    "gg" #'beginning-of-buffer
    "G" #'end-of-buffer
    "q" #'bury-buffer
    "gr" #'pgmacs--table-list-redraw
    "?" #'pgmacs--table-list-help
    "go" #'pgmacs-open-table
    "gp" #'pgmacs--display-procedures
    "e" #'pgmacs-run-sql
    "E" #'pgmacs-run-buffer-sql
    "=" #'pgmacs--shrink-columns
    "r" #'pgmacs--redraw-pgmacstbl
    "gT" #'pgmacs--switch-to-database-buffer
    (kbd "TAB") #'pgmacs--next-item)

  ;; Table list buffer when point is in a table
  (evil-define-key* 'normal pgmacs-table-list-map/table
    "j" #'evil-next-line
    "k" #'evil-previous-line
    "l" #'pgmacstbl-next-column
    "h" #'pgmacstbl-previous-column
    (kbd "RET") #'pgmacs--table-list-RET
    "D" #'pgmacs--table-list-delete
    "gS" #'pgmacs--schemaspy-database
    "gR" #'pgmacs--table-list-rename
    "gj" #'pgmacs--row-as-json
    "gv" #'pgmacs--view-value
    "<" (lambda () (interactive)
          (text-property-search-backward 'pgmacstbl)
          (forward-line))
    ">" (lambda () (interactive)
          (text-property-search-forward 'pgmacstbl)
          (forward-line -1))
    "g0" (lambda () (interactive) (pgmacstbl-goto-column 0))
    "g1" (lambda () (interactive) (pgmacstbl-goto-column 1))
    "g2" (lambda () (interactive) (pgmacstbl-goto-column 2))
    "g3" (lambda () (interactive) (pgmacstbl-goto-column 3))
    "g4" (lambda () (interactive) (pgmacstbl-goto-column 4))
    "g5" (lambda () (interactive) (pgmacstbl-goto-column 5))
    "g6" (lambda () (interactive) (pgmacstbl-goto-column 6))
    "g7" (lambda () (interactive) (pgmacstbl-goto-column 7))
    "g8" (lambda () (interactive) (pgmacstbl-goto-column 8))
    "g9" (lambda () (interactive) (pgmacstbl-goto-column 9)))

  ;; Row list buffer bindings (viewing table rows)
  (evil-define-key* 'normal pgmacs-row-list-map
    "j" #'evil-next-line
    "k" #'evil-previous-line
    "l" #'pgmacstbl-next-column
    "h" #'pgmacstbl-previous-column
    "gg" #'beginning-of-buffer
    "G" #'end-of-buffer
    "q" #'bury-buffer
    "?" #'pgmacs--row-list-help
    "I" #'pgmacs--insert-row-empty
    "go" #'pgmacs-open-table
    "r" #'pgmacs--redraw-pgmacstbl
    "gr" #'pgmacs--row-list-redraw
    "e" #'pgmacs-run-sql
    "E" #'pgmacs-run-buffer-sql
    "gW" #'pgmacs--add-where-filter
    "gS" #'pgmacs--schemaspy-table
    "gT" #'pgmacs--switch-to-database-buffer
    (kbd "TAB") #'pgmacs--next-item)

  ;; Row list buffer when point is in a table (editing rows)
  (evil-define-key* 'normal pgmacs-row-list-map/table
    "j" #'evil-next-line
    "k" #'evil-previous-line
    "l" #'pgmacstbl-next-column
    "h" #'pgmacstbl-previous-column
    (kbd "RET") #'pgmacs--row-list-dwim
    "w" #'pgmacs--edit-value-widget
    "!" #'pgmacs--shell-command-on-value
    "&" #'pgmacs--async-command-on-value
    "gU" #'pgmacs--upcase-value
    "gu" #'pgmacs--downcase-value
    "g~" #'pgmacs--capitalize-value
    "gv" #'pgmacs--view-value
    "dd" #'pgmacs--row-list-delete-row
    "x" #'pgmacs--row-list-delete-marked
    (kbd "DEL") #'pgmacs--row-list-delete-row
    "gR" #'pgmacs--row-list-rename-column
    "a" #'pgmacs--insert-row
    "gi" #'pgmacs--insert-row-widget
    "yy" #'pgmacs--copy-row
    "p" #'pgmacs--yank-row
    "=" #'pgmacs--shrink-columns
    "gj" #'pgmacs--row-as-json
    "m" #'pgmacs--row-list-mark-row
    "u" #'pgmacs--row-list-unmark-row
    "U" #'pgmacs--row-list-unmark-all
    "<" (lambda () (interactive)
          (text-property-search-backward 'pgmacstbl)
          (forward-line))
    ">" (lambda () (interactive)
          (text-property-search-forward 'pgmacstbl)
          (forward-line -1))
    "g0" (lambda () (interactive) (pgmacstbl-goto-column 0))
    "g1" (lambda () (interactive) (pgmacstbl-goto-column 1))
    "g2" (lambda () (interactive) (pgmacstbl-goto-column 2))
    "g3" (lambda () (interactive) (pgmacstbl-goto-column 3))
    "g4" (lambda () (interactive) (pgmacstbl-goto-column 4))
    "g5" (lambda () (interactive) (pgmacstbl-goto-column 5))
    "g6" (lambda () (interactive) (pgmacstbl-goto-column 6))
    "g7" (lambda () (interactive) (pgmacstbl-goto-column 7))
    "g8" (lambda () (interactive) (pgmacstbl-goto-column 8))
    "g9" (lambda () (interactive) (pgmacstbl-goto-column 9)))

  ;; Procedure list buffer bindings
  (evil-define-key* 'normal pgmacs-proc-list-map
    "j" #'evil-next-line
    "k" #'evil-previous-line
    "l" #'pgmacstbl-next-column
    "h" #'pgmacstbl-previous-column
    "gg" #'beginning-of-buffer
    "G" #'end-of-buffer
    "q" #'bury-buffer
    "?" #'pgmacs--proc-list-help
    (kbd "RET") #'pgmacs--proc-list-RET
    (kbd "TAB") #'pgmacs--next-item
    "dd" #'pgmacs--proc-list-delete
    "gT" #'pgmacs--switch-to-database-buffer
    "gR" #'pgmacs--proc-list-rename
    "<" (lambda () (interactive)
          (text-property-search-backward 'pgmacstbl)
          (forward-line))
    ">" (lambda () (interactive)
          (text-property-search-forward 'pgmacstbl)
          (forward-line -1)))

  ;; Transient buffer bindings (query results, etc.)
  (evil-define-key* 'normal pgmacs-transient-map
    "j" #'evil-next-line
    "k" #'evil-previous-line
    "gg" #'beginning-of-buffer
    "G" #'end-of-buffer
    "q" #'bury-buffer
    "go" #'pgmacs-open-table
    "e" #'pgmacs-run-sql
    "E" #'pgmacs-run-buffer-sql
    "gT" #'pgmacs--switch-to-database-buffer)

  ;; Paginated buffer bindings (for large tables)
  (evil-define-key* 'normal pgmacs-paginated-map
    "]p" #'pgmacs--paginated-next
    "[p" #'pgmacs--paginated-prev))
#+end_src
*** Javascript/Typescript
I don't write a lot of Javascript or Typescript, so I haven't invested a lot of
time building a proper configuration for those modes. In what experience I have
had, running code actions through =SPC-c-a= doesn't work as well as the language
servers for Go or Rust, so I've enabled auto fixes to run on save to avoid
running eslint through a shell or fixing those lint failures by hand.
#+begin_src elisp
;; Provides configuration for using 'eslint' with Emacs
(use-package! lsp-eslint
  :defer
  :config
  ;; Automatically fix trivial lint failures
  (setq lsp-eslint-auto-fix-on-save t))
#+end_src
*** Rust
RLS has been deprecated as the primary language server for Rust and
rust-analyzer is official language server going forward. I've set rust-analyzer
as my language server choice and enabled procedural macro expansion and build
script support.
#+begin_src elisp
;; Provides configuration for working with the Rust programming language
(use-package! rustic
  :defer
  :config
  ;; Use 'rust-analyser', and enable options that allow further completion
  ;; support for crates that rely on macros and build scripts
  (setq lsp-rust-server 'rust-analyzer
        lsp-rust-analyzer-proc-macro-enable t
        lsp-rust-analyzer-cargo-run-build-scripts t)
  ;; For some reason this has been lowered to 2 which conflicts with rustfmt,
  ;; override this back to 4 spaces
  (setq rustic-indent-offset 4))
#+end_src
*** Python
I like using hard line wraps to keep my Python comments tidy, so let's use a
hook to enable =python-docstring-mode= for any Python buffers. This minor mode
lets me use =fill-paragraph= while keeping everything Pythonic, and enables syntax
highlighting in docstrings.
#+begin_src elisp
;; Provides better Emacs support for Python docstrings
(use-package! python-docstring-mode
  :hook python-mode)

;; Use ruff instead of black for formatting, apheleia already defines the
;; formatter so we can just modify the mapping in the alist.
(after! python
  (set-formatter! 'ruff :modes '(python-mode python-ts-mode)ยง))
#+end_src
*** Go
Out of the box, =go-mode= provides everything I need, but visualising coverage
using the =go-coverage= command is kind of lacklustre. This is kind of a bad hack
job but my Elisp isn't great. After loading in the =+go--run-tests= function, I've
defined my own function for running it, then automatically calling =go-coverage=
against the generated output, then binding that to a shortcut underneath the
local leader key.
#+begin_src elisp :tangle no
;; Provides configuration for working with the Go programming language
(use-package! go-mode
  :defer
  :config
  ;; Runs Go tests, and generate a coverage profile to 'cover.out'
  ;;
  ;; Note: this function does not currently clean up the produced coverage profile
  ;; once you're done.
  (defun go-cover-buffer ()
    (interactive)
    (+go--run-tests "-coverprofile cover.out")
    (go-coverage "cover.out"))
  ;; Make 'go-cover-buffer' available through the local leader key map
  (map! :map go-mode-map
        :localleader
        :prefix "t" ; t for tests
        :desc "view coverage" "c" #'go-cover-buffer))
#+end_src
*** PlantUML
The standard file extension is =.plantuml= but I've got many files that use =.puml=
instead. Add a mapping for this file extension to use =plantuml-mode= as the major
mode for these files.
#+begin_src elisp
(add-to-list 'auto-mode-alist '("\\.puml\\'" . plantuml-mode))
#+end_src
** Writing
*** Org Mode
Org Mode is probably the most popular markdown format for Emacs users, and has a
bunch of functionality and plugins available for use with it. For example, you
can use it to provide literate programming functionality, such as how this
document is set up to tangle into a final =config.el= setup that Emacs actually
ingests.

For writing in Org, I've configured a few things:
+ Hiding in-line text markup
+ Automatically hard wrapping text at 80 characters
+ Using =pdf-tools= for viewing PDF output
+ Increasing the font size of the first and second heading levels
+ Some opinionated LaTeX config
#+begin_src elisp
;; Provides configuration for working with 'org-mode'
(use-package! org
  ;; Wrap text at 80 characters for better Git diffs and readability
  :hook (org-mode . auto-fill-mode)
  ;; Org is a large package, defer loading but also load during downtime to
  ;; prevent hangs on first load
  :defer-incrementally t
  :config
  (setq org-log-done 'time ; Record timestamps on task completion for org-agenda usage
        org-agenda-start-with-log-mode t ; Start agenda in log mode with timestamps for completion displayed
        org-hide-emphasis-markers t ; Hide emphasis markers that wrap text (i.e. bold, italics)
        +org-capture-todo-file "Tasks.org" ; Capture tasks to ~/org/Tasks.org
        org-archive-location "::* Archive") ; Archive sub-trees to an "Archive" top-level heading

  ;; Use 'pdf-tools' as the default viewer for exported Org documents
  (add-to-list 'org-file-apps '("\\.pdf\\'" . pdf-tools))
  ;; Enlarge top and second level heading fonts
  (custom-set-faces!
    '(org-level-1
      :height 1.2
      :inherit outline-1)
    '(org-level-2
      :height 1.1
      :inherit outline-2))
  ;; Collect agenda from Org and Org Roam
  (setq org-agenda-files '("~/org"
                           "~/org/roam"
                           "~/org/roam/daily"))
  ;; Enable export support for LaTeX and BibTeX formats
  (require 'ox-latex)
  (require 'ox-bibtex)


  ;; Tectonic is a self-contained LaTeX engine, and downloads dependencies on the
  ;; fly, so I can avoid using a massive install of texlive-full.
  ;;
  ;; It also handles re-runs automatically for tools like Bibtex.
  (setq org-latex-pdf-process
        ;; PDF process expects a list of commands here as pdflatex normally
        ;; needs to be repeated.
        ;;
        ;; Since tectonic handles this automatically, we only need one item. The
        ;; `,` marker is used to partially evaluate the list so that
        ;; `doom-user-dir` is correctly concatenated using its value.
        `(,(concat "tectonic --outdir=%o %f -Z search-path=" doom-user-dir "latex")))

  ;; Better syntax highlighting in exported LaTeX
  (setq org-latex-src-block-backend 'engraved)
  ;; Enable additional packages for exported LaTeX, takes the form:
  ;;    ("options" "package" SNIPPET-FLAG COMPILERS)
  (setq org-latex-packages-alist '(("" "booktabs")
                                   ("" "tabularx")
                                   ("" "color")))
  ;; Define 'mimore' LaTeX document class for use in exports
  (add-to-list 'org-latex-classes
               '("mimore"
                 "\\documentclass{mimore}\n\[NO-DEFAULT-PACKAGES\]\n\[PACKAGES\]\n\[EXTRA\]"
                 ("\\section{%s}" . "\\section\*{%s}")
                 ("\\subsection{%s}" . "\\subsection\*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection\*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph\*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph\*{%s}")))
  (setq org-latex-default-class "mimore"))
#+end_src
**** Org-Tree-Slide
If LaTeX beamer presentations aren't your thing, or you want to use literate
programming to run code in live presentations; it's possible to hold
presentations directly from Org Mode itself.

I use the =org-tree-slide= package for this, which requires some basic
configuration. For my use case, I tell =org-tree-slide= to skip all headings above
the top level for slide generation, which effectively means I just treat top
level headings as slides. At time of writing, there are three different default
profiles available, so I've enabled the fancy one with all the animation bells
and whistles.
#+begin_src elisp
;; Provides support for presenting directly from 'org-mode' buffers
(use-package! org-tree-slide
  :after org
  :config
  ;; Hide formatting characters, use top-level headings as slides
  (setq org-tree-slide-skip-outline-level 2)
  ;; Use the fancy presentation profile, shiny animations!
  (org-tree-slide-presentation-profile))
#+end_src
**** Org Roam & UI
Org Roam can be used to extend Org Mode to become a personal wiki of sorts. I am
still trying to incorporate it more into my workflow, so the configuration here
is relatively sparse.
#+begin_src elisp
;; Provides configuration for 'org-roam', an Emacs knowledge graph
(use-package! org-roam
  :after org
  :config
  ;; Hide common link types from org-roam graph
  (setq org-roam-graph-link-hidden-types
        '("file"
          "http"
          "https")))
#+end_src

For inspecting a large Org Roam database, =org-roam-ui= is pretty good. I haven't
enabled starting it automatically on launching org-roam just yet as I want to
use roam more before I go that far. Most of the config here just follows the
recommendations from [[https://github.com/org-roam/org-roam-ui][org-roam-ui's README]].
#+begin_src elisp
;; Provides 'websocket', a dependency of 'org-roam-ui'
(use-package! websocket
  :after org-roam)

;; Provides 'org-roam-ui' a web frontend for 'org-roam'
(use-package! org-roam-ui
  :after org-roam
  :config
  ;; Sync UI theme with Emacs, follow current the buffer, update on save, and
  ;; open browser on start
  (setq org-roam-ui-sync-theme t
        org-roam-ui-follow t
        org-roam-ui-update-on-save t
        org-roam-ui-open-on-start t))
#+end_src
**** Calendar
I really like having a full calendar view in addition to the view provided by
=org-agenda=, which can be provided by =calfw=. By default, Doom's =calendar= module
installs the package, but doesn't provide a key binding so you can define your
own calendar function. For now, I'm just using the calendar from my =org-agenda=,
so I just need to map that function to a key.
#+begin_src elisp
(map! :leader
      :prefix ("o" . "open")
      :desc "Open calendar" "c" #'cfw:open-org-calendar)
#+end_src
*** Markdown
You can use =grip-mode= to provide GitHub markdown previews, but by default you'll
get rate limited by the GitHub API. To avoid this you'll need to authenticate
with a personal access token.
#+begin_src elisp
;; You'll need to require the auth-source library. It's built into Emacs.
(require 'auth-source)

;; Fetch API credentials from ~/.authinfo or ~/.netrc
(let ((credential (auth-source-user-and-password "api.github.com")))
  (setq grip-github-user (car credential)
        grip-github-password (cadr credential)))
#+end_src
** Tooling
*** Kubernetes
Define autoloads for commands from =kele=, and enable =evil-mode= bindings for use
with the Kubernetes management interface.

=kele= provides a comprehensive Kubernetes client for Emacs with transient-based
menus. This configuration enables it and sets up evil bindings for its various
buffer types.
#+begin_src elisp
;; Provides configuration for interacting with Kubernetes clusters from within
;; Emacs
(use-package! kele
  :init
  ;; Provide key map to access 'kele' from leader key
  (map! :leader
        :desc "Kubernetes" "k" #'kele-dispatch))
  ;; 'kele-dispatch' requires 'kele-mode' to be enabled to watch Kubernetes
  ;; resources
  ;;(kele-mode))

;; Kele evil-mode integration
;; Kele uses magit-section-mode and vtable for its list buffers. Set up proper
;; evil bindings for navigation and actions.
(after! kele
  ;; Set initial evil state to normal for kele list buffers
  (evil-set-initial-state 'kele-list-mode 'normal)
  (evil-set-initial-state 'kele-get-mode 'normal)

  ;; List mode bindings (viewing resources like pods, deployments, etc.)
  (map! :map kele-list-mode-map
        :n "j" #'evil-next-line
        :n "k" #'evil-previous-line
        :n "gg" #'beginning-of-buffer
        :n "G" #'end-of-buffer
        :n "q" #'quit-window
        :n "gr" #'kele-list-refresh
        :n [return] #'kele-list-table-dwim
        :n "d" #'kele-list-kill
        :n [tab] #'vtable-next-column
        :n [backtab] #'vtable-previous-column
        :n "]]" #'magit-section-forward
        :n "[[" #'magit-section-backward
        :n "gj" #'magit-section-forward-sibling
        :n "gk" #'magit-section-backward-sibling
        :n "za" #'magit-section-toggle
        :n "zc" #'magit-section-hide
        :n "zo" #'magit-section-show)

  ;; Get mode bindings (viewing individual resource YAML)
  (map! :map kele-get-mode-map
        :n "j" #'evil-next-line
        :n "k" #'evil-previous-line
        :n "gg" #'beginning-of-buffer
        :n "G" #'end-of-buffer
        :n "q" #'quit-window
        :n "Q" #'kele--quit-and-kill
        :n "gr" #'kele-refetch)

  ;; Table navigation within list buffers
  (map! :map kele-list-table-map
        :n [return] #'kele-list-table-dwim
        :n "d" #'kele-list-kill))
#+end_src
*** AI Assistants
/AI is all the rage these days./
**** gptel
=gptel= provides an LLM client for Emacs that can be used to chat with LLMs.
#+begin_src elisp
(use-package! gptel
  :config
  ;; using claude sonnet 4 for my chosen default AI model
  (setq gptel-model #'gpt-5
        ;; gptel uses markdown-mode by default, use org-mode instead
        gptel-default-mode #'org-mode
        ;; override the doom emacs llm module to display buffer side-by-side
        gptel-display-buffer-action t
        ;; use branching context mode
        gptel-org-branching-context t
        ;; configure github copilot backend
        gptel-backend (gptel-make-gh-copilot "Copilot"))
  ;; Register LLM community tool collection
  (mapc (apply-partially #'apply #'gptel-make-tool)
        (llm-tool-collection-get-all))

  ;; Install Macher presets for agentic use
  (macher-install)

  ;; since branching mode is enabled, don't use headings in prompt prefixes
  (setf (alist-get 'org-mode gptel-prompt-prefix-alist) "@user\n")
  (setf (alist-get 'org-mode gptel-response-prefix-alist) "@assistant\n")

  ;; add keybind for activating gptel-mode on an old org-buffer
  (defun my/gptel-toggle-and-enable-solaire ()
    (interactive)
    (gptel-mode 'toggle)
    (solaire-mode 'toggle))
  (map! :leader
        :prefix ("o" . "open")
        (:prefix ("l" . "llm")
         :desc "Toggle gptel-mode and enable solaire-mode" "t" #'my/gptel-toggle-and-enable-solaire))
   ;; enable automatic scrolling of llm responses
  (add-hook #'gptel-post-stream-hook #'gptel-auto-scroll))
#+end_src
**** ECA (Editor Code Assistant)
=eca-emacs= provides an agentic coding assistant that integrates with Emacs. The
chat interface uses its own keymaps which don't play well with evil-mode out of
the box, so we need to configure evil bindings.
#+begin_src elisp
;; ECA configuration
;; Set default model to Claude Opus 4.5 via GitHub Copilot
(setq eca-chat-custom-model "github-copilot/claude-opus-4.5")

;; ECA evil-mode integration
;; ECA uses markdown-mode based buffers with custom keymaps that don't work well
;; with evil-mode. This configuration sets up proper evil bindings for the chat
;; and MCP details buffers.
(after! eca-chat
  ;; Set initial evil state to insert for chat buffers (for typing prompts)
  ;; but use normal mode for navigation
  (evil-set-initial-state 'eca-chat-mode 'normal)

  ;; Chat buffer bindings
  (map! :map eca-chat-mode-map
        ;; Normal mode - navigation and actions
        :n "j" #'evil-next-line
        :n "k" #'evil-previous-line
        :n "gg" #'beginning-of-buffer
        :n "G" #'end-of-buffer
        :n "q" #'bury-buffer
        :n "gr" #'eca-chat-reset
        :n "gc" #'eca-chat-clear
        :n [return] #'eca-chat--key-pressed-return
        :n [tab] #'eca-chat--key-pressed-tab

        ;; Chat navigation
        :n "[[" #'eca-chat-go-to-prev-user-message
        :n "]]" #'eca-chat-go-to-next-user-message
        :n "[e" #'eca-chat-go-to-prev-expandable-block
        :n "]e" #'eca-chat-go-to-next-expandable-block
        :n "za" #'eca-chat-toggle-expandable-block

        ;; Tool call approval (crucial for agentic workflows)
        :n "ga" #'eca-chat-tool-call-accept-all
        :n "gA" #'eca-chat-tool-call-accept-next
        :n "gs" #'eca-chat-tool-call-accept-all-and-remember
        :n "gx" #'eca-chat-tool-call-reject-next

        ;; Chat management
        :n "gn" #'eca-chat-new
        :n "gf" #'eca-chat-select
        :n "gm" #'eca-chat-select-model
        :n "gb" #'eca-chat-select-behavior
        :n "gB" #'eca-chat-cycle-behavior
        :n "gR" #'eca-chat-rename
        :n "gh" #'eca-chat-timeline
        :n "g," #'eca-mcp-details
        :n "g." #'eca-transient-menu

        ;; Prompt operations
        :n "gp" #'eca-chat-repeat-prompt
        :n "gd" #'eca-chat-clear-prompt
        :n "gt" #'eca-chat-talk

        ;; Insert mode - for typing in prompts
        :i "S-<return>" #'eca-chat--key-pressed-newline
        :i "C-<up>" #'eca-chat--key-pressed-previous-prompt-history
        :i "C-<down>" #'eca-chat--key-pressed-next-prompt-history
        :i [return] #'eca-chat--key-pressed-return
        :i [tab] #'eca-chat--key-pressed-tab

        ;; Visual mode - for selecting text
        :v "y" #'evil-yank

        ;; Leader key bindings for common operations
        :localleader
        :n "a" #'eca-chat-tool-call-accept-all
        :n "A" #'eca-chat-tool-call-accept-next
        :n "s" #'eca-chat-tool-call-accept-all-and-remember
        :n "r" #'eca-chat-tool-call-reject-next
        :n "n" #'eca-chat-new
        :n "f" #'eca-chat-select
        :n "m" #'eca-chat-select-model
        :n "b" #'eca-chat-select-behavior
        :n "B" #'eca-chat-cycle-behavior
        :n "R" #'eca-chat-rename
        :n "c" #'eca-chat-clear
        :n "k" #'eca-chat-reset
        :n "t" #'eca-chat-talk
        :n "h" #'eca-chat-timeline
        :n "," #'eca-mcp-details
        :n "." #'eca-transient-menu))

;; MCP details buffer bindings
(after! eca-mcp
  (evil-set-initial-state 'eca-mcp-details-mode 'normal)

  (map! :map eca-mcp-details-mode-map
        :n "j" #'evil-next-line
        :n "k" #'evil-previous-line
        :n "gg" #'beginning-of-buffer
        :n "G" #'end-of-buffer
        :n "q" #'bury-buffer
        :n "gr" #'eca-mcp-details
        :n [return] #'push-button
        :n [tab] #'forward-button
        :n [backtab] #'backward-button
        :n "g," #'eca
        :n "g." #'eca-transient-menu))
#+end_src
* Packages
I use some packages from [[https://melpa.org][MELPA]] that Doom Emacs doesn't expose through =init.el=.
These are imported using Doom's =package!= macro.
#+begin_src elisp :tangle packages.el
;; -*- no-byte-compile: t; -*-
;;; .doom.d/packages.el

;; Doom Emacs

;; Behaviour Driven Development (BDD)
(package! feature-mode)

;; Python
(package! python-docstring) ; provides syntax highlighting and fill-paragraph
                            ; functionality

;; gRPC
(package! protobuf-mode) ; work with .proto files

;; Kubernetes
(package! kele)
(package! jsonnet-mode)

;; Org
(unpin! org-roam) ; use latest version of org-roam
(package! org-roam-ui) ; enable org-roam-ui server
(package! engrave-faces) ; comprehensive latex code output

;; PostgreSQL
(package! ; dependency of pgmacs
  pg :recipe
  (:host github
   :repo "emarsden/pg-el"))
(package!
  pgmacs :recipe
  (:host github
   :repo "emarsden/pgmacs"))

;; AI Tools
(unpin! gptel) ; use latest version of gptel, many bugs abound
(package!
  llm-tool-collection :recipe
  (:host github
   :repo "skissue/llm-tool-collection"))
(package!
  macher :recipe
  (:host github
   :repo "kmontag/macher"))
(package!
  eca :recipe
  (:host github
   :repo "editor-code-assistant/eca-emacs"
   :files ("*.el")))

;; Miscellaneous
(package! command-log-mode)
(package! prism)
(package! flyover)
(package! eat)
#+end_src
* Workarounds
** MacOS
MacOS has a few things that can sometimes cause issues with Doom Emacs. Here's
some configuration that only activates on MacOS installs to fix those.
#+begin_src elisp
;; MacOS only configuration
(when (featurep :system 'macos)
  ;; Mac UK keyboard layout puts the '#' symbol under Opt + 3 which
  ;; conflicts with Doom's workspace shortcuts.
  ;;
  ;; Rebind this in insert mode only so that I can still use the hash
  ;; symbol.
  (map! :i "M-3" #'(lambda () (interactive) (insert "#")))
  ;; BSD sed doesn't work with Man-mode, use the GNU variant.
  (setq Man-sed-command "gsed"))
#+end_src
